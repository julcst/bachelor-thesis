
\chapter{Related Work}
\label{chap:related}
The research related to this thesis can be divided into three main categories:
First, I will give a short overview over several relevant approaches to the global illumination problem.
After that, I will specifically discuss methods that reuse computed radiance estimates across time or space.
Finally, I will take a closer look into papers that apply neural networks to rendering.
For a more in-depth overview over the whole field I refer to \textcite{ritschel2012} and for photon mapping in particular to \textcite{kang2016}.

\section{Global Illumination}
In the early days of rendering, lighting was limited to direct illumination and ray traced reflections \bcite{whitted1980} and indirect illumination was often hand-crafted \bcite{christensen2016}.

\paragraph{Finite Element Methods}
\textcite{goral1984} were the first to also compute indirect illumination, which they achieved by dividing the scene into finite elements and solving the resulting system of equations.
Their approach was limited to diffuse surfaces, though later papers extended this idea to non-diffuse surfaces \bcite{immel1986}.
However, the separation of the scene into finite elements generally results in visible bias, particularly for complex geometry.

\paragraph{Monte Carlo Methods}
The first universal unbiased algorithm to solve the global illumination problem was given by \textcite{kajiya1986}, who formulated a radiance estimator based on Monte Carlo integration.
Simultaneously, \textcite{arvo1986} discovered the potential of light tracing to simulate indirect lighting effects.
\textcite{lafortune1993} later combined light tracing and pathtracing into Bidirectional Pathtracing (BDPT), and \textcite{veach1997} introduced provably optimal weighting strategies to maximize convergence speed.
\textcite{keller1995,owen1995} improved convergence of Monte-Carlo samplers in general by using low discrepancy samples.
Furthermore, \textcite{veach1997a} also proposed a new mutation based sampling strategy which exceeds in finding low-probability high-contribution paths which can cause significant noise in classic Monte Carlo methods.
In addition, Manifold Exploration techniques were developed which excel at discovering highly specular paths \bcite{jakob2012}.

\paragraph{Photon Mapping}
Simultaneously, a number of generally biased radiance estimators emerged that are based on storing outgoing flux \textit{(photons)} in spatial data structures (original work: \cite{jensen1996}; overview: \cite{kang2016}).
This method is conceptually equivalent to Arvo's light tracing approach \bcite{arvo1986} but stores lighting information in space opposed to on surfaces.
The original estimator of \textcite{jensen1996} was made consistent by \textcite{hachisuka2008,knaus2011} and extended by \textcite{hachisuka2009a} to also handle glossy surfaces efficiently.
\textcite{georgiev2012} further improved the quality by integrating bidirectional path tracing and shadow tests into photon mapping.

\paragraph{Real-time Photon Mapping}
As the original method for photon mapping \bcite{jensen1996} used highly incoherent k-d-tree traversal to perform Fixed-Radius-Near-Neighbor (FRNN) searches, it was not well suited for GPU execution.
To solve this, \textcite{hachisuka2010} proposed to stochastically store photons in a fixed-size hash grid, which improves parallelization and reduces memory access, yet increases noise.
\textcite{mara2013} later published four further GPU-optimized photon mapping algorithms.
However, with the recent advancements in GPU architectures, traversal of bounding volume hierarchies can be hardware accelerated.
\textcite{evangelou2021} successfully leveraged these modern hardware features to perform fast FRNN queries, leading \textcite{kern2023} to apply this to photon mapping and together with culling and stochastic rejection they achieve real-time performance.

\paragraph{Path Guiding}
Alternatively, to obtain unbiased estimators, photon maps \bcite{jensen1996} can also be used only to \textit{guide} path sampling \bcite{jensen1995}.
\textcite{vorba2014} later improved upon this idea by learning Gaussian Mixture Models.

\section{Path Reuse}

\paragraph{Precomputed GI}
Under the assumption of static geometry and lighting, radiance information can also be precomputed and reused at runtime.
The first paper to explicitly introduce this concept was \textcite{greger1998} who proposed precomputing irradiance inside a volume to capture indirect illumination, although photon maps \bcite{jensen1996} and illumination maps \bcite{arvo1986,heckbert1990} were already similar in concept.
\textcite{sloan2002} expanded on this idea by using spherical harmonics to represent the radiance field, allowing for real-time directional global illumination by simply evaluating the dot product between the coefficients of the radiance field and the surface transfer function, a more approachable introduction to their paper is given by \textcite{green2003}.
Since their invention, various improvements to the original method were made \bcite{krivanek2007}.
Notably, \textcite{kautz2002} generalized this technique to arbitrary BRDFs.
\textcite{mcguire2017} approached the light leaking problem by introducing light probes that capture radial distance together with radiance in octahedral maps \bcite{engelhardt2008,cigolle2014} which they use for efficient visibility tests.
These precomputed methods have become ubiquitous in real-time rendering applications \bcite{odonnell2018,iwanicki2017} but have the fundamental drawback of being static.

\paragraph{Dynamic Radiance Caching}
In contrast to precomputed GI techniques, radiance caching algorithms are fully dynamic and online.
\textcite{ward1988} lay the groundwork for radiance caching with their seminal paper on the topic.
Their key idea was to evaluate the radiance field only sparsely and to render full resolution images by interpolating nearby samples.
\textcite{tole2002} generalized this approach to dynamic scenes and arbitrary radiance estimators and \textcite{krivanek2005} used spherical harmonics to enable radiance caching for generic BSDFs.

Recently, dynamic radiance caching has received renewed attention with several game engines and companies shipping it in production for dynamic GI.
\textcite{majercik2019} use dynamic probe placement to make the light probing technique of \textcite{mcguire2017} dynamic, which was used in major game titles at Ubisoft \bcite{kuenlin2024}.

\textcite{wright2021,wright2022} combine screen- and world-space radiance caching with efficient screen-space ray tracing and SDF cone tracing to achieve real-time global illumination in production in Unreal Engine 5.
Building on this, \textcite{boisse2023} replaced the world-space cache with a spatial hash and \textcite{tatzgern2024} explored the use of On-Surface Caches.

At EA, \textcite{stachowiak2018,halen2021,apers2024} place a fixed amount of surface elements \textit{(surfels)} on the scene geometry on the fly to accumulate irradiance.
These surfels are also used for self-learning to simulate infinite bounce indirect lighting.

\paragraph{Path Space Filtering}
Another interesting and closely related technique is that of Path Space Filtering \bcite{keller2016}, where similar path segments are averaged to reduce noise.
\textcite{binder2021} adapted this technique to GPU hardware by introducing spatial hash grids.

\paragraph{Reservoir-based Resampling (ReSTIR)}
The most recent advancements in path tracing are based on spatio-temporal path reuse through reservoir resampling (original work: \cite{bitterli2020}; generalization: \cite{lin2022}; see also \cite{wyman2023}) and already achieve acceptable noise at close to real-time performance.
The core idea is to draw samples from a pool of reused candidates according to their estimated contribution, and was already motivated by \textcite{talbot2005}.
These methods are also fully dynamic, yet they differ from radiance caching in that they are theoretically unbiased.
Although the original paper used reservoir resampling only for direct illumination \bcite{bitterli2020}, the idea was recently extended among others to indirect lighting \bcite{ouyang2021}, full path tracing \bcite{lin2022}, photon mapping \bcite{kern2024} and bidirectional path tracing \bcite{hedstrom2025}.
ReSTIR can also be combined with other techniques like radiance caching \bcite{muller2021,majercik2021,boisse2023}.

\section{Neural Rendering}
With the recent advancements in Deep Learning, neural rendering techniques have gained great interest in the rendering community and have been applied to a vast array of rendering problems.

\paragraph{Neural Importance Sampling}

\paragraph{Neural Interpolation}
\textcite{iwanicki2017} use a neural network to efficiently weight irradiance probes in space to prevent light leaking.
Similarly, \textcite{zhu2020} use a neural network to predict kernels for photon mapping based on the neighborhood of photons to improve the quality of density estimation.

\paragraph{Neural Radiance Caching}
Neural Radiance Fields (NeRF) \bcite{mildenhall2020} have recently received a lot of attention in the field of Computer Vision to represent 3D scenes.
\textcite{muller2021} used a NeRF-like neural network architecture as backing storage for radiance caching, which they call Neural Radiance Caching (NRC).
\textcite{muller2022} improved on the original NRC-paper by introducing a versatile positional input encoding based on feature vectors distributed in multi-resolution hash grids.
Recently, \textcite{dereviannykh2024} adapted the NRC to cache \textit{incident} radiance.

\paragraph{Neural Denoising}
Because Monte-Carlo rendering algorithms are unbiased but noisy, denoising can be highly effective to trade the remaining variance for a small bias.
Although hand-crafted spatiotemporal filters can also achieve good results \bcite{schied2017}, recurrent autoencoders are well-suited for high quality screen-space denoising of Monte-Carlo rendered images \bcite{chaitanya2017} and are nowadays widely used in production \bcite{afra2019}.
Neural Radiance Caching \bcite{muller2021} can also be interpreted as a form of Path Space Filtering \bcite{keller2016}. % TODO: check